---
title: 代币标准：ERC20 vs ERC721 vs ERC1155
description: null
author: 李留白
weight: 1
date: 2022-06-05T02:51:47.964Z
lastmod: 2022-06-05T05:48:47.610Z
tags: []
categories:
  - 区块链
featuredImage: https://cdn.jsdelivr.net/gh/hicoldcat/assets@main/img/ERC20-vs-ERC721-vs-ERC1155-1.png
---

> 原文：[https://www.leewayhertz.com/erc-20-vs-erc-721-vs-erc-1155/](https://www.leewayhertz.com/erc-20-vs-erc-721-vs-erc-1155/) <br/>
> 翻译：李留白

以太坊的开发是为了解决第一代区块链--比特币的局限性。Vitalik Bueterin提出了具有集成智能合约功能的开源区块链的想法，以扩大区块链在各主要行业的使用案例。被誉为100%可编程的以太坊生态系统欢迎全世界的区块链爱好者在其生态系统的基础上开发区块链驱动的解决方案，并为增长做出贡献。

以太坊代币开发是普遍存在的开发机会之一，它维护了整个网络和众多相互关联的项目同时运行。基于以太坊的代币可以代表价值和服务，创新公司将这些代币作为内部货币，在生态系统内进行买卖和交易。

现在，以太坊支持代币开发，其社区也制定了一些标准，以确保在以太坊上创建的代币可以与各种现有的生态系统兼容，并满足特定的用户需求。你应该知道，以太坊也允许用户创建一个可替换的代币，而不需要遵守任何ERC标准。

这些类型的代币缺乏与以太坊上其他任何东西的兼容性，如Defi交易所和钱包。因此，ERC代币标准对于提出构建各种智能合约的基本准则至关重要。这些标准不时演变，为ERC代币开发提供更好的接口，以便企业能够满足其特定的用户需求。

这一见解增加了对以太坊代币标准的深入分析，以及对当今领先的四大ERC代币标准的深入研究 ----- ERC20与ERC721与ERC1155。

## 什么是以太坊的ERC？

ERC是Ethereum Request for Comments的首字母缩写。它就像技术文档，定义了适用于一群想要利用以太坊生态系统的开发者和用户的方法、行为、创新和研究。

你可能想知道谁有权力创建和管理ERC。以太坊的智能合约程序员负责编写ERC相关文件，以描述每个基于以太坊的Token必须遵守的一系列规则。他们还经常审查这些文件，并对其进行评论以进一步改进。

要轻松理解ERC，可以考虑成立一个工程任务组，向开发人员传达技术说明和规则，如果每个人都想利用特定生态系统的好处，那么他们都需要遵守这些技术说明和规则。

## 什么是ERC代币标准？

ERC代币标准解释了所有建立在以太坊区块链上的ERC代币的某些规则。以太坊的社区会适当审查这套规则，并根据不断变化的要求进行修订。此外，ERC标准的设计是为了让ERC代币能够无缝互动。

ERC-20、ERC-721和ERC-1155作为三种流行的ERC代币标准或协议出现，在各大行业都有其应用。以太坊社区完全批准了这些代币标准，它们在具体特征和功能方面有所不同。

在了解代币标准的具体含义或工作原理之前，我们首先应该了解以太坊上智能合约标准的要点。以下语句对其进行了定义。

智能合约描述了智能合约程序员应遵守的规则，以利用以太坊网络的潜在优势。
这些标准适用于支持智能合约和去中心化应用（dApps）开发的区块链。
智能合约标准包含代币标准、库的主题与格式、名称注册和相关细节。
ERC代币标准只是智能合约标准的另一个名称。以太坊上的智能合约必须遵守标准或规则，以实现代币创建、交易处理、支出等基本功能。通过引入改进的ERC标准，以太坊释放了其生态系统的真正潜力，并授权开发更具体的智能合约，促进网络的增长。

## 以太坊代币标准的演变

以太坊持续推出不同的ERC代币标准，以使生态系统更易于使用，并支持各种用例。从ERC-20到ERC-721再到ERC-1155，以太坊社区成功地将此区块链打造成一个永远不会过时的主流协议。

下面，我们讨论了以太坊代币标准到目前为止是如何发展的，以及目前与之相关的不同ERC令牌标准。因此，我们将研究全世界企业和用户在以太坊区块链上的增长范围和发展机会。

![](https://cdn.jsdelivr.net/gh/hicoldcat/assets@main/img/微信截图_20220605110631.png)

## ERC-20代币标准

ERC-20在2015年首次被提出，两年后的2017年，最终融入以太坊生态系统。ERC-20介绍了在以太坊区块链上创建可互换代币的代币标准。简单地说，ERC-20由支持开发相同代币的属性组成。

例如，表示货币的ERC-20代币可以像以太坊的原生货币--以太币一样工作。这意味着1个代币将永远等于另一个代币的价值，并且可以相互交换。ERC 20代币为可替换代币的发展设定了标准，但可替换代币实际上能代表什么？让我们来看看它们。

- 任何在线平台的信誉值。
- 彩票和计划。
- 金融资产，如公司的股份、红利和股票。
- 法定货币，包括美元。
- 黄金盎司，以及更多...

以太坊需要一个强大的标准来实现整个运营的统一，以支持代币开发并在区块链网络上对其进行监管。这就是为什么ERC-20可以进入游戏领域。

去中心化世界的开发者为了不同的目的，广泛使用ERC-20代币标准，比如开发可互操作的代币应用，与以太坊生态系统中的其他产品和服务兼容。

### ERC-20代币的特点

- ERC 20代币是 "可替代性代币 "的另一个名称。
- 可替代性定义了资产或代币兑换相同价值资产的能力，例如两张1美元纸币。
- 无论其特征和结构如何，每个ERC-20代币都严格等同于相同的价值。
- ERC代币最受欢迎的应用领域是稳定币、治理代币和ICO。

## ERC-721：不可互换的代币

要了解ERC-721标准，你必须首先了解NFTs（不可替代的代币）。看看我们解释NFTs的详细见解，以及它们在区块链的去中心化世界中的作用。

Cryptokitties（广为流传的非同质化代币）的创始人、CTO Dieter Shirley最初提议开发一种新的代币类型来支持NFTs。该提案将于2018年晚些时候获得批准。它专门用于NFTs，这意味着遵守ERC-721的规则开发的代币可以代表以太坊区块链上任何数字资产的价值。

至此，我们得出结论：如果ERC-20对于发明新的加密货币至关重要，那么ERC-721对于代表某个人对这些数字资产所有权的证明来说是很有价值的。ERC-721可以表示以下内容：

- 一个独特的数字艺术品
- 推文和社交媒体文章
- 游戏中的收藏品
- 游戏人物
- 任何卡通人物和数以百万计的其他NFTs....

这种特殊类型的代币为利用NFTs的企业带来了惊人的可能性。同样，ERC-721也为他们带来了挑战，为了应对这些挑战，ERC-721标准开始发挥作用。

请注意，每个NFTs都有一个uint256变量，称为tokenId。因此，对于每个EBR-721合同，合同地址键值对 uint256 tokenId必须是唯一的。

此外，dApps还应该有一个 "converter"来调节NFTs的输入和输出过程。例如，converter将tokenId视为输入，并输出不可伪造的代币，如僵尸图像、杀戮、游戏收藏品等。

### ERC-721代币的特点

- ERC-721代币是不可伪造的代币（NFTs）的标准。
- 这些代币不能被兑换成同等价值的东西，因为它们是独一无二的。
- 每个ERC-721代表各自NFT的价值，可能有所不同。
- ERC-721代币最受欢迎的应用领域是游戏中的NFTs。

## ERC-1155:多代币标准

结合ERC-20和ERC-720的能力，Witek Radomski（Enjin的首席技术官）为Ethereum智能合约引入了一个包罗万象的代币标准。这是一个标准接口，支持开发同质化的、半同质化的、非同质化的代币和其他配置的通用智能合约。

现在，您可以使用单个接口满足所有代币开发需求并解决问题，从而使ERC-1155成为游戏规则的改变者。这样一个独特的代币标准的想法是开发一个强大的智能合约接口，代表和管理不同形式的ERC代币。

ERC-1155的另一个优点是，它改善了以前ERC代币标准的整体功能，使以太坊生态系统更加高效和可扩展。

### ERC-1155代币的特点

- ERC-1155是一个智能合约接口，代表同质化的、半同质化的和非同质化的代币。
- ERC-1155可以执行ERC-20和ERC-720的功能，甚至可以同时执行两者。
- 每个代币都可以根据代币的性质代表不同的价值；同质化的、半同质化的和非同质化的。
- ERC-1155适用于创建NFT、可兑换购物券、ICO等。

## ERC-20、ERC-721和ERC-1155的接口是怎样的？

### ERC-20

以下是ERC20的基本接口，描述了ERC20合约的功能和事件特征，接下来是对每个给定功能的解释。

```sol
contract ERC20 {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    function totalSupply() public view returns (uint256);

    function balanceOf(address who) public view returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);

    function allowance(address owner, address spender)
        public
        view
        returns (uint256);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);
}
```

以下是ERC-20智能合约接口的特点和组成部分。

#### totalsupply

函数totalSupply是公开的，因此所有人都可以访问。它显示了目前正在流通的代币的总数。由于这个totalSupply函数被标记为视图修改器，所以它不消耗gas。此外，每当有新的代币被铸造出来，它就会更新内部的代币值totalSupply。

```
// its value is increased when new tokens are minteduint256 totalSupply_;
// access the value of totalSupply_function totalSupply() public view returns (uint256) {  return totalSupply_;}
```

#### balanceOf

balanceOf是另一个带有视图修改器的公共函数，每个人都能访问，而且是不消耗gas的。它接受以太坊地址并返回该地址拥有的代币数量。

```
// Updated when tokens are minted or transferredmapping(address => uint256) balances;
// Returns tokens held by the address passed as _ownerfunction balanceOf(address _owner)  public view returns (uint256 balance) {  return balances[_owner];}
```

#### transfer

transfer函数与上述两个功能不同，因为它需gas，而且会导致以太坊智能合约的变化。应各代币持有人的请求，它将代币从一个地址转移到另一个地址。

```
function transfer(address _to, uint256 _value) public returns (bool) {
    // Check for blank addresses
    require(_to != address(0));
    // Check to ensure valid transfer
    require(_value <= balances[msg.sender]);
    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    // Event transfer defined in the ERC 20 interface above
    Transfer(msg.sender, _to, _value);
    return true;
}
```

#### allowance, approve and transferFrom

最后的函数 allowance, approve, 和 transferFrom 支持如授权其他一些以太坊地址代表各自的持有人使用代币的高级功能。

### ERC-721

为了了解ERC-721是如何工作的，让我们看看它内部的接口。

```sol
contract ERC721 {
    event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 _tokenId
    );
    event Approval(
        address indexed _owner,
        address indexed _approved,
        uint256 _tokenId
    );

    function balanceOf(address _owner) public view returns (uint256 _balance);

    function ownerOf(uint256 _tokenId) public view returns (address _owner);

    function transfer(address _to, uint256 _tokenId) public;

    function approve(address _to, uint256 _tokenId) public;

    function takeOwnership(uint256 _tokenId) public;
}
```

#### balanceOf

在下面的片段中， ownedTokens表示一个特定地址的完整的代币ID列表。而balanceOf函数返回该地址的代币数量。

```
mapping (address => uint256[]) private ownedTokens;
function balanceOf(address _owner) public view returns (uint256) {  return ownedTokens[_owner].length;  }
```

#### OwnerOf

映射token所有者拥有的token，并输出该持有者的id。然而，由于它的可见性被设置为私有，通过使用ownerOf函数，你可以将这个映射的值设置为公共。同时它还需要在返回值之前对零地址进行检查。

```
mapping (uint256 => address) private tokenOwner;
function ownerOf(uint256 _tokenId) public view returns (address) {  
    address owner = tokenOwner[_tokenId];    
    require(owner != address(0));    
    return owner;  
}
```

#### transfer

这个transfer函数将要转给的所有者的账户地址作为_to参数，要转移的token的id作为_tokenId参数，同时注意，它只能由token的当前所有者调用。它必须包括检查转移是否清除转移所需的批准检查的逻辑。然后是从当前所有者中移除令牌的所有权并将其添加到新所有者拥有的令牌列表的逻辑。

```
modifier onlyOwnerOf(uint256 _tokenId) {   require(ownerOf(_tokenId) == msg.sender);    _;  }function transfer(address _to, uint256 _tokenId)   public onlyOwnerOf(_tokenId) {   // Logic to clear approval for token transfer  // Logic to remove token from current token owner  // Logic to add Token to new token owner  }
```

#### approve

Approve 是另一个函数，用于声明给定令牌ID的所有权。它被一个只有OwnerOf的修饰语所限制，这说明只有代币持有者可以出于明确的原因访问这个函数。

```
mapping (uint256 => address) private tokenApprovals;
modifier onlyOwnerOf(uint256 _tokenId) {   
    require(ownerOf(_tokenId) == msg.sender);   
    _;  
}
function approvedFor(uint256 _tokenId)   public view returns (address) {     
    return tokenApprovals[_tokenId];  
}
function approve(address _to, uint256 _tokenId)  public onlyOwnerOf(_tokenId) {    
    address owner = ownerOf(_tokenId);   
    require(_to != owner);  
    if (approvedFor(_tokenId) != 0 || _to != 0) {    
        tokenApprovals[_tokenId] = _to;    
        // Event initialised in the interface above   
         Approval(owner, _to, _tokenId);   
    }
}
```



#### takeOwnership

函数takeOwnership接收_tokenId并对消息发送者进行同样的检查。如果他通过了类似于转移函数的检查逻辑，他必须返回拥有_tokenID的所有权账户地址。

```
function isApprovedFor(address _owner, uint256 _tokenId)   internal view returns (bool) {    
    return approvedFor(_tokenId) == _owner;  
}
function takeOwnership(uint256 _tokenId) public { require(isApprovedFor(msg.sender, _tokenId));  
// Logic to clear approval for token transfer  
// Logic to remove token from current token owner  
// Logic to add Token to new token owner}
```


### ERC-1155

#### Batch Transfers

批量转移与常规ERC-20转移密切相关。让我们来看看ERC-20 transferFrom函数。

```
// ERC-20function transferFrom(address from, address to, uint256 value) external returns (bool);
// ERC-1155function 
safeBatchTransferFrom(address _from,address _to,uint256[] calldata _ids,uint256[] calldata _values,bytes calldata _data) external;
```

ERC-1155的不同之处在于将令牌值作为一个数组和一个id数组传递。转移的结果是这样的。

- 将200个ID为5的代币从_from转移到_to。
- 将300个ID为7的代币从_from转到_to。
- 从_from 转移3个id为15的代币到_to。

除了利用ERC-1155的函数作为transferFrom，没有转移，你可以通过设置表格地址到调用函数的地址来利用它作为常规转移。

#### Batch Balance

相较于的ERC-20 balanceOf调用，同样具有其支持批处理的功能。提醒一下，这是ERC-20版本：

```
// ERC-20function balanceOf(address owner) external view returns (uint256);// ERC-1155function balanceOfBatch(address[] calldata _owners,uint256[] calldata _ids) external view returns (uint256[] memory);
```

对于余额调用来说更简单，我们可以在一次调用中检索到多个余额。我们传递所有者的数组，然后是令牌ID的数组。
例如，给定_ids=[3, 6, 13]和_owners=[0xbeef..., 0x1337..., 0x1111...]，返回值将是：

```
[balanceOf(0xbeef...),balanceOf(0x1337...),balanceOf(0x1111...)]
```

#### Batch Approval

```
// ERC-1155function setApprovalForAll(address _operator,bool _approved) external;function isApprovedForAll(address _owner,address _operator) external view returns (bool);
```

这里的approvals 与ERC-20略有不同。你需要使用setApprovalForAll将操作员设置为已批准或未批准，而不是批准特定的金额。

#### Receive Hook

```
function onERC1155BatchReceived(address _operator,address _from,uint256[] calldata _ids,uint256[] calldata _values,bytes calldata _data) external returns(bytes4);
```

ERC-1155只支持智能合约的接收钩子。钩子函数必须返回一个预定义的magic bytes4值，如下所示。

```
bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))
```

一旦接收合约返回这个值，我们就认为该合约现在可以接受转让，而且它了解如何管理ERC-1155代币。这就完成了!

## ERC20 vs. ERC721 vs. ERC1155 比较

如果你想在以太坊区块链上创建任何种类的代币，那么你必须知道ERC-20、ERC721和ERC之间的区别。能够区分这些最普遍的ERC，你就可以选择正确的代币标准，完美地符合你的业务特定需求。

| 技术规格 | ERC-20 | ERC-721	 | ERC-1155 |
| :------ | :------ | :------ | :------- |
| 使用的便利性 | 每笔交易需要进行单一操作 | 每笔交易需要进行单一操作 | 允许在一次交易中进行多项操作 |
| BME（燃烧和铸造）模型 | 没有 | 有 | 有 |
| 支持的代币 | 同质化代币 | 非同质化代币 | 同质化和非同质代币 |
| KYC核查 | 不需要KYC验证 | 内建的KYC/AML | 内建的KYC/AML |
| 用例 | Bianance Coin, Maker, OmiseGo | Decentraland, Cryptokitties, Ethermon | Reedemable shopping vouchers |
| 智能合约 | 需要一个共同的智能合约 | 要求每个代币有一个独特的智能合约 | 需要一个单一的智能合约来实现无限的代币 |
| 效率 | 需要更多的存储空间 | 可能需要更多的存储空间 | 需要更少的存储空间 |
| 代币转移 | 可以一次转移1或2个代币 | 支持单一代币一次性转移 | 支持许多代币的批量转移 |
| 本地化 | 支持单一语言 | 支持单一语言 | 支持语言的本地化 |
| 转移类型 | 用户之间的价值转移 | 权利的转让 | 价值或权利的转让 |

### ERC-20, ERC-721, ERC-1155, ERC-下一步是什么？

以太坊代币标准还有哪些变化？为了给出这个问题的合适答案，让我们简要概述即将推出的ERC代币标准及其对以太坊智能合约的潜在影响。

#### ERC-3475: 多重可赎回债券

ERC-3475是以太坊社区推出的最新智能合约标准，支持创建可管理多种可赎回或可赎回债券的代币。使用ERC-3475，企业可以存储债券的集体信息，推出各种类型的债券，在现有的债券中整合额外的功能和特性，这对去中心化金融市场的发展至关重要。

#### ERC-3475是如何工作的？

- ERC-20是目前全球流行的LP（流动性提供者）代币，但它需要为每个代币部署单独的智能合约。考虑到这一点，ERC-3475为债券的发行者提供了多次债券赎回的便利。
- 通过这样做，这个新的ERC标准证明是一个真正的突破，帮助以太坊区块链用户为现有的分散债券市场建立更好的基础设施。
- ERC-3475可以有效地管理多个可赎回的债券，存储大量的数据而不需要消耗很多gas。因此，它具有成本效益。


## ERC20、ERC721或ERC1155的具体使用案例是什么？

即使以太坊旨在通过每一个新的ERC标准使代币开发成为一个简单的过程，但我们必须同意，所有现有的代币标准在今天都是相关的，并且与不同行业及其特定的用户需求相关。以下是ERC代币的具体使用案例。

#### ERC-20的使用案例

ERC-20代表了可替代资产的价值，对于组织众筹活动、发行ICO和在市场上推出更多的加密货币是非常有用的。

#### ERC-721的使用案例

ERC-721代表某人对数字资产的所有权，主要用作游戏行业的NFT，NFT市场和Metaverse平台。


#### ERC-1155的使用案例

多用途代币标准--ERC1155，经常用于网络游戏。现在的游戏有可替代的元素，如生命/能量，NFT如游戏角色，和可替代的原生货币来交换价值。

## 总结

以太坊发布新代币标准的动机是为了应对区块链世界不断发展的变化。每个ERC代币标准的独特功能对希望利用Ethereum的不同企业和开发者来说都是一种好处。三种代币ERC20、ERC721和ERC1155目前在数字生态系统中是非常有效和包容的。然而，以太坊代币标准的不断发展，可能会在未来几年内带来区块链的根本性进步。

![](https://cdn.jsdelivr.net/gh/hicoldcat/assets@main/img/my.png)
 