+++
title = "以太坊小示例和基本概念"
pubdate = "2021-12-25"
featuredImage = "/eth/cover.png"
categories = ["web3"]
+++

> 声明：市场有风险，投资需谨慎，币圈骗子多，一定要小心，违法的事不要做，违法的人不结识，仅供学习，致力于用区块链技术打造和谐社会。

本文所涉及的项目代码：

https://github.com/yu-tou/eth-self-token-example

# 在以太坊发布自己的 token 代码示例

```bash
yarn install
# 启动本地网络
yarn chain
```

token 代码在 `./contracts`，其中 `YuTou.sol` 是 token 合约，`YuTouMintable` 是发币合约

编辑合约后，部署脚本在 `deploy/00_deploy_your_contract.js`，如合约名有变化则修改

```bash
# 部署到本地网络
yarn deploy

```

执行成功后终端，有合约地址，将地址导入钱包，即可看到 token

钱包使用测试网络连接合约后可以获取自己的一个地址，接下去向地址发 token

修改合约地址和账户地址，在 `scripts/mint.js` 中

```bash
# 发币到自己的账户
yarn mint
```

# 以太坊概念教程

## 1. 以太坊基础概念

### 1.1 比特币 BTC & 以太坊 Ethereum

- 比特币：价值工具。
- 以太坊：分布式应用平台。

### 1.2 智能合约 contract

智能合约（Smart contract ）是一种旨在以信息化方式传播、验证或执行合同的计算机协议。智能合约允许在没有第三方的情况下进行可信交易，这些交易可追踪且不可逆转

智能合约是用诸如 Solidity, Serpent 或 LLL 之类的高级脚本语言编写的，部署于分布式网络的虚拟机中，可以认为是传统应用的服务端

### 1.3 web3.js

开发以太坊区块链应用程序，涉及到以下部分:

- 智能合约开发 – 使用 solidity 语言编写代码，部署到区块链。
- 网站或客户端开发 – 与区块链中的智能合约进行交互，读写数据。

在进行网站或客户端开发时，就需要用到 web3.js。web3.js 库是一个 javascript 库，可以让你执行很多与区块链进行交互的任务，例如：

- 以太币转账（信息交换）
- 读写智能合约中的数据
- 创建智能合约

web3.js 使用 JSON RPC 与 Ethereum 区块链通信(JSON RPC 即 JSON 远程调用)，对区块链网络进行数据读写

web3 连接使用合约地址连接，具体连接到的是分布式网络中的节点。

### 1.4 以太币 eth

- 应用程序执行任何操作都需要支付以太币，防范以太坊网络被滥用。
- 与比特币类似，用于激励矿工。

### 1.5 油费 gas

以太坊(Ethereum)区块链网络上，每一次操作的执行都需要消耗“汽油/gas”，用户需要支付“油费”，“油费”用以太币计算，价格由矿工决定，矿工可以拒绝执行油费出价过低的智能合约。

每个智能合约都有一个设置的 Gas 最大消耗量，被称为 Gas 上限 / Gas Limit，如果有人试图执行一段死循环的合约代码，合约将一直运行，最终超过 gas 上限，调用合约的交易将回滚到以前状态

### 1.6 虚拟机 EVM

虚拟机是执行智能合约代码的引擎，可以被看做是一个大型的分布式计算机网络，执行的代码是编译后的智能合约代码。

### 1.7 分布式应用 DAPP

分布式应用(DApp)是运行在区块链之上的应用程序，支持区块链网络中用户之间的交互。

### 1.8 账号(地址）accounts

以太坊(Ethereum)网络中，有 2 种账号：

- 外部账号 – 用户使用的账号
- 合约账号 – 智能合约使用的账号，每个智能合约都有一个账号

这些账号，都被称为状态对象/state object，构成了以太坊网络的状态。外部账号的状态是账户余额，合约账号的状态是内存与账户余额

通常，钱包里的账号，就是外部账号，一个智能合约部署后，会默认有一个 deployer 账号和一个合约地址，合约地址是合约账号，可以使用这个地址导入 token 到钱包。

### 1.9 虚拟机架构

- 开发人员使用 Solidity 等开发语言开发智能合约
- 源程序被编译成以太坊虚拟机支持的字节码可执行程序
- 可执行程序被部署到网络中，即写入区块，并被分配一个账号(地址)
- 外部账号或其他合约账号，可以通过该智能合约的账号访问它

### 1.10 网络节点

以太坊(Ethereum)网络是一个公共的区块链网络，网络中包含 2 种网络节点：

- 全节点
- 轻节点

全节点 包含了从初始区块开始的全部区块，这些区块中包含了所有的交易历史记录，这些信息是区块链完整性的证据，可用于区块和交易的校验。通常矿工节点应该是全节点。

轻节点 只包含区块头形成的链，为节省空间，去除了区块体。这些类型的节点主要用于电子钱包，电子钱包必须是轻量级的，因此不能存储整个区块链。轻节点不会用来校验区块或交易，但区块链是一个网络，如有必要轻节点可以向全节点请求区块数据。

### 1.11 挖矿

以太坊(Ethereum)与其他公共区块链一样，使用工作量证明机制确保区块链网络正常运行。矿工进行工作量证明计算，即挖矿，来选择区块，写入区块链，确认交易。

以太坊使用的工作量证明算法称为 Ethash，这是一种哈希算法，灵感来自 Dagger-Hashimoto 算法

## 2. 交易

### 2.1 钱包

MetaMask、walletConnect 等，可以管理自己的地址，适配标准代币协议，可以快速与 dapp 建立链接，进行账号授权，快速交易等。

MetaMask 核心功能

- 选择不同主链网络
- 导入账户，使用私钥或者助记词导入
- 导入代币，import token，使用代理合约的部署地址导入。
- 转账、收款。
- 连接 dapp。

### 2.2 稳定币

最常用的是 usdt，所有币币之间的交易，通常都是通过 usdt 中转，另外以 usdt 作为余额使用、计价单位。

USDT 又名 Tether，通过 Tether 提供 1：1 美元兑换服务，为法币与数字货币提供兑换服务，网站宣称严格遵守 1：1 的准备金保证，即每发行 1 枚 USDT 代币，其银行帐户都会有 1 美元的资金保障。理论上 usdt 有泡沫风险，如果挤兑可能会爆盘，但是目前的确是最通用的稳定币

### 2.3 交易方式

- c2c：通过线下 c 对 c 交易，将法币兑换成虚拟币，或者将虚拟币兑换成法币。
- 币币：虚拟币和虚拟币之间的兑换。
- 杠杆交易：杠杆交易也是一种现货交易，需要持有一定量的币或者 USDT，通过抵押借贷来进行访大交易，盈亏风险同比访大。通常操作：做空或者做多。
- 合约交易：一种自动杠杆交易，需提供动态保证金，上涨到一定价格可 100 倍收益，但是下跌强平会损失所有保证金。
- 期权：用来对冲风险，

### 2.4 中心化交易所

火币（国内）、okex（国内）、币安（新加坡），目前国内的交易所都已经清退国内用户，美国也是禁止提供交易服务的国家，币安在新加坡，还可以交易，但是 c2c 交易比较困难。

交易方式：将币从自己的地址转入交易所提供的地址，然后快速进行币币交易（兑换）或杠杆/期权等交易，交易过程不会上链，没有链上记录，所以是中心化交易所，有跑路风险，容易被攻击。

### 2.5 去中心化交易所

如 uniswap，通过标准的区块链方式来进行币币交易，交易需要矿工挖矿，速度比较慢，比较安全，过程公开。

## 3. 代币

### 3.1 ERC20 协议

ERC-20 是以太坊区块链上的一种智能合约协议标准，规定了合约代币需实现的核心方法，只要实现了这些方法，并且部署到链上，即可发行代币，将合约地址导入钱包，即可自动识别 token 名和其他信息。

### 3.2 代币价值

还没搞懂

### 3.3 代币流通

还没搞懂

## 4. 智能合约开发

### 4.1 本地虚拟机

可以使用 hardhat 进行智能合约开发，首先需要运行一个本地的虚拟机，用以运行所有的合约及提供对合约的访问。

对于本项目，运行以下命令，运行之后不要退出，保持进程持续运行，每次重启都会丢失测试数据。

```
npm run chain
```

### 4.2 编写合约代码

合约代码的开发语言通常是 `Solidity` ，文件后缀 `.sol`，开发工具建议 vscode + Solidity 插件。

Solidity 语法有点类似 js 或者 java 等，面向对象编程。

合约可以运行任何逻辑，可以是一段计算逻辑，或者是数据存储，也可以是代币协议等。

本项目的合约是一个代币合约，代码见 ./contracts/

其中 YuTou.sol 是代币合约，YuTouMintable 是一个扩展类，使代币具备分配能力。

### 4.3 部署合约代码

编写合约后，通过 npm run deploy 命令部署，本项目的部署脚本在 deploy/00_deploy_your_contract.js 中，指定了部署的合约名等。

合约部署其实很简单，部署后会分配一个合约地址和 deployer 账号地址，需记住这两个地址，导入 token 到钱包需要合约地址，deployer 地址则持有了初始发行的所有 token

### 4.4 发币

代码和注释见 scripts/mint.js

只有 deployer 才有权限向其他账号发布初始 token。
核心逻辑：

```js
// 调用mint方法向 0x437431... 账户发行代币;
contract.methods
  .mint("0x4374311B5d68E9eC496B70a55b8dD9469c804D1C", 512 * 10 ** 8)
  // from需要是所有者，因为发布的时候没有选择用户，默认是创世用户第一个，才可以向想合约申请给用户发币
  .send({
    from: "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
  });
```

### 4.5 回币

在合约中有一段代码

```js
//接收以太坊可以使用回退函数，在回退函数里给调用者地址发相同数量的代币
receive() external payable {
    require(msg.value > 0);
    _mint(msg.sender, msg.value);
}
constructor() public payable {
}
```

此段代码是监听 eth 主链上的转账通知，当 当前合约部署的合约地址收到 eth 转账的时候，会进入此逻辑，可以给转账发起方回复 token，可以以此实现 eth 到 代币的自动兑换（不过这好像不合法）
